;; Disperse: Being able to send TON to multiples wallets at the same time using an smart contract BUT ALSO jetton tokens. I can also select % instead of amount.
;; Collect: Being able to collect TON from multiples at the same time and send just to one wallet using an smart contrct but ALSO Jeton tokens using % of the wallet. This should be developed in Rust

#include "imports/stdlib.fc";

const op::add_wallet = "op::add_wallet"c;
const op::add_jetton_wallet = "op::add_jetton_wallet"c;
const op::transfer = "op::transfer"c;
const op::transfer_jetton = "op::transfer_jetton"c;

global slice ctx_owner_addr;
global slice ctx_src_jetton_wallet_addr;
global int ctx_dest_wallet_count;
global cell ctx_dest_wallet_addr_dict;
global int ctx_dest_jetton_wallet_count;
global cell ctx_dest_jetton_wallet_addr_dict;

() save_data() impure inline {
    ~strdump("Start save_data()");
    set_data(
        begin_cell()
            .store_slice(ctx_owner_addr)
            .store_slice(ctx_src_jetton_wallet_addr)
            .store_uint(ctx_dest_wallet_count, 32)
            .store_ref(ctx_dest_wallet_addr_dict)
            .store_uint(ctx_dest_jetton_wallet_count, 32)
            .store_ref(ctx_dest_jetton_wallet_addr_dict)
        .end_cell()
    );
    ~strdump("End save_data()");
}

() load_data() impure {
    ~strdump("opa_na");
    slice ds = get_data().begin_parse();
    ~strdump("opa_na");
    ctx_owner_addr = ds~load_msg_addr();
    ~strdump("opa_na");
    if (ds.slice_empty?()) { ;; ignore all empty messages
        ctx_src_jetton_wallet_addr = begin_cell().end_cell().begin_parse();
        ctx_dest_wallet_count = 0;
        ctx_dest_wallet_addr_dict = new_dict();
        ctx_dest_jetton_wallet_count = 0;
        ctx_dest_jetton_wallet_addr_dict = new_dict();
    }

    ;; Wallets
    ~strdump("opa_na");
    ctx_dest_wallet_count = ds~load_uint(32);
    ~strdump("opa_na");
    if (ctx_dest_wallet_count == 0) {
        ctx_dest_wallet_addr_dict = new_dict();
    }
    ~strdump("opa_na");
    ctx_dest_wallet_addr_dict = ds~load_dict();

    ;; Jetton Wallets
    ~strdump("opa_na");
    ctx_dest_jetton_wallet_count = ds~load_uint(32);
    ~strdump("opa_na");
    if (ctx_dest_jetton_wallet_count == 0) {
        ctx_dest_jetton_wallet_addr_dict = new_dict();
    }
    ~strdump("opa_na");
    ctx_dest_jetton_wallet_addr_dict = ds~load_dict();
    ~strdump("opa_na");
    ds.end_parse();
}

() main(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    load_data(); ;; here we populate the storage variables

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

    if (op == op::add_wallet) {
        
        slice new_wallet_addr = in_msg_body~load_msg_addr();

        (int key, _, int success?) = ctx_dest_wallet_addr_dict.udict_get_max?(32);
        ctx_dest_wallet_addr_dict.udict_add?(32, key, new_wallet_addr);
        ctx_dest_wallet_count = ctx_dest_wallet_count + 1;
        
        save_data();
        return ();
    }

    if (op == op::add_jetton_wallet) {


        
        save_data();
        return ();
    }

}

slice get_owner_addr() method_id {
    load_data();
    return ctx_owner_addr;
}

int get_wallet_count() method_id {
    load_data();
    return ctx_dest_wallet_count;
}

cell get_wallets() method_id {
    load_data();
    return ctx_dest_wallet_addr_dict;
}

int get_jetton_wallet_count() method_id {
    load_data();
    return ctx_dest_jetton_wallet_count;
}
